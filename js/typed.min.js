(function (window, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports"], factory);
  } else if (typeof module === "object" && module.exports) {
    factory(module, module.exports);
  } else {
    factory(window, window);
  }
})(this, function (global, exports) {
  "use strict";

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

  var createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();

  var Typed = (function () {
    function Typed(el, options) {
      if (!(this instanceof Typed)) {
        throw new TypeError("Cannot call a class as a function");
      }

      this.el = el;
      this.options = options;
      this.isInput = this.el.tagName.toLowerCase() === "input";
      this.attr = this.options.attr;
      this.bindInputFocusEvents = this.options.bindInputFocusEvents;
      this.showCursor = !this.isInput && this.options.showCursor;
      this.cursorChar = this.options.cursorChar;
      this.cursorBlinking = this.options.cursorBlinking;
      this.elContent = this.attr ? this.el.getAttribute(this.attr) : this.el.textContent;
      this.contentType = this.options.contentType;
      this.typeSpeed = this.options.typeSpeed;
      this.startDelay = this.options.startDelay;
      this.backSpeed = this.options.backSpeed;
      this.smartBackspace = this.options.smartBackspace;
      this.backDelay = this.options.backDelay;
      this.fadeOut = this.options.fadeOut;
      this.fadeOutClass = this.options.fadeOutClass;
      this.fadeOutDelay = this.options.fadeOutDelay;
      this.isPaused = false;
      this.strings = this.options.strings.map(function (s) { return s.trim(); });
      this.stringsElement = typeof this.options.stringsElement === "string"
        ? document.querySelector(this.options.stringsElement)
        : this.options.stringsElement;
      this.strPos = 0;
      this.arrayPos = 0;
      this.stopNum = 0;
      this.loop = this.options.loop;
      this.loopCount = this.options.loopCount;
      this.curLoop = 0;
      this.shuffle = this.options.shuffle;
      this.sequence = [];
      this.pause = this.options.pauseForEachString;
      this.pauseIndex = 0;
      this.pauseTimes = [];
      this.complete = this.options.onComplete;
      this.preStringTyped = this.options.preStringTyped;
      this.onStringTyped = this.options.onStringTyped;
      this.typingPaused = this.options.typingPaused;
      this.typingResumed = this.options.typingResumed;
      this.resetCallback = this.options.resetCallback;
      this.text = "";

      if (typeof this.options.stringsElement === "function") {
        this.options.stringsElement.call(this);
      }

      this.begin();
    }

    createClass(Typed, [
      {
        key: "toggle",
        value: function toggle() {
          if (this.pause.status) {
            this.startTyping();
          } else {
            this.stopTyping();
          }
        }
      },
      {
        key: "stopTyping",
        value: function stopTyping() {
          this.isPaused = true;
          clearTimeout(this.timeout);
        }
      },
      {
        key: "startTyping",
        value: function startTyping() {
          this.isPaused = false;
          this.typewrite(this.strings[this.sequence[this.arrayPos]], this.strPos);
        }
      },
      {
        key: "begin",
        value: function begin() {
          var self = this;

          if (this.options.onBegin) {
            this.options.onBegin(this);
          }

          if (this.elContent && this.strings.length < 1) {
            this.strings = [this.elContent];
          }

          if (this.shuffle) {
            for (var i = 0; i < this.strings.length; i++) {
              this.sequence[i] = i;
            }
          } else {
            this.sequence = this.strings.map(function (s, i) { return i; });
          }

          this.currentElContent = "";
          if (this.contentType === "html") {
            this.currentElContent = this.el.innerHTML;
          }

          this.insertCursor();

          if (this.options.autoInsertCss) {
            this.loadCSS();
          }

          this.timeout = setTimeout(function () {
            self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);
          }, this.startDelay);
        }
      },
      {
        key: "typewrite",
        value: function typewrite(str, pos) {
          var self = this;

          if (this.isPaused || this.fadeOut) {
            this.timeout = setTimeout(function () {
              self.typewrite(str, pos);
            }, 30);
            return;
          }

          str = str.replace(/\^(\d+)/, "");
          if (str.length > pos) {
            this.insertText(str.charAt(pos));
          } else {
            this.arrayPos++;
          }

          this.timeout = setTimeout(function () {
            pos++;
            self.typewrite(str, pos);
          }, this.typeSpeed);
        }
      },
      {
        key: "insertText",
        value: function insertText(char) {
          if (this.isInput) {
            this.el.value += char;
          } else if (this.contentType === "html") {
            this.el.innerHTML += char;
          } else if (this.attr) {
            this.el.setAttribute(this.attr, this.el.getAttribute(this.attr) + char);
          } else {
            var node = document.createTextNode(char);
            this.el.appendChild(node);
          }
        }
      },
      {
        key: "insertCursor",
        value: function insertCursor() {
          if (this.showCursor) {
            if (!this.cursor) {
              this.cursor = document.createElement("span");
              this.cursor.className = "typed-cursor";
              this.cursor.innerHTML = this.cursorChar;
              if (this.el.parentNode) {
                this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);
              }
            }
          }
        }
      },
      {
        key: "loadCSS",
        value: function loadCSS() {
          if (!this.cssLoaded) {
            this.cssLoaded = true;
            var style = document.createElement("style");
            style.type = "text/css";
            style.innerHTML = ".typed-cursor{opacity:1;}.typed-cursor.typed-cursor--blink{animation:typedjsBlink 0.7s infinite;}@keyframes typedjsBlink{50%{opacity:0;}}";
            document.body.appendChild(style);
          }
        }
      }
    ]);

    return Typed;
  })();

  exports.default = Typed;
  module.exports = exports.default;
});
